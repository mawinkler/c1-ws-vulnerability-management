#!/usr/bin/python3

DOCUMENTATION = """
---
module: policy_on_tenable_report.py

short_description: Retrieves CVEs discovered by Tenable Vulnerability
                   Management and assigns IPS rules to instances managed by
                   Cloud One Workload Security.

description:
    - "TODO"

options:
    --query       cves to handle (manual query)

author:
    - Markus Winkler (markus_winkler@trendmicro.com)
"""

EXAMPLES = """
./policy_on_tenable_report.py
"""

RETURN = """
TODO
"""

import ssl

ssl._create_default_https_context = ssl._create_unverified_context
import urllib3

urllib3.disable_warnings()
import argparse
import json
import os
import os.path
import pickle
import pprint
from datetime import datetime
from io import StringIO
import requests
import yaml
from requests.auth import HTTPBasicAuth

pp = pprint.PrettyPrinter()


def severity(i):
    switcher = {
        0: "Very Low",
        1: "Low",
        2: "Medium",
        3: "High",
        4: "Critical",
    }
    return switcher.get(i, "Invalid severity")


def get_tenable_last_active_scan_id(cfg):
    """
    Retrieve last active scan id from Tenable
    """

    # assemble the url
    tenable_uri = "https://" + cfg["tenable"]["server"] + "/rest/scanResult"

    tenable_header_val = {
        "x-apikey": "accesskey="
        + cfg["tenable"]["api_accesskey"]
        + ";secretkey="
        + cfg["tenable"]["api_secretkey"]
        + ";",
        "User-Agent": "Tenable-TippingPoint-converter",
    }

    # initiate the get-command
    tenable_resp = requests.get(tenable_uri, headers=tenable_header_val, verify=False)
    tenable_data = tenable_resp.json()

    # get amount of available scans
    tenable_scan_list = tenable_data["response"]["usable"]
    tenable_scan_list_len = len(tenable_scan_list)

    # search latest scan-result incl "status"==Completed , search backwards
    scan = tenable_scan_list_len - 1
    while scan >= 0:
        if (
            tenable_scan_list[scan]["name"] == cfg["tenable"]["active_scan"]
            and tenable_scan_list[scan]["status"] == "Completed"
        ):
            tenable_last_active_scan_id = tenable_scan_list[scan]["id"]
            va_report_name = tenable_scan_list[scan]["name"]
            print("Tenable scan ID: " + tenable_last_active_scan_id)
            scan = 0  # direct jump out of the while Loop
        scan -= 1

    # nothing found => exit execution
    if int(tenable_last_active_scan_id) < 0:
        result = 'no finished active-scan "' + cfg["tenable"]["active_scan"] + '" found'
        quit(result)

    return tenable_last_active_scan_id


def get_tenable_ip_data(cfg, tenable_last_active_scan_id):
    """
    Retrieve IP data from Tenable
    """

    # assemble the url
    tenable_uri = "https://" + cfg["tenable"]["server"] + "/rest/scanResult"

    tenable_header_val = {
        "x-apikey": "accesskey="
        + cfg["tenable"]["api_accesskey"]
        + ";secretkey="
        + cfg["tenable"]["api_secretkey"]
        + ";",
        "User-Agent": "Tenable-TippingPoint-converter",
    }

    # fire the get request
    tenable_resp_scan_id = requests.get(
        tenable_uri,
        params={"id": tenable_last_active_scan_id},
        headers=tenable_header_val,
        verify=False,
    )
    tenable_scan_id_data = tenable_resp_scan_id.json()

    # get IPs via analysis-request
    # assemble new url
    tenable_uri = "https://" + cfg["tenable"]["server"] + "/rest/analysis"

    tenable_ip_val = {
        "query": {
            "type": "vuln",
            "tool": "sumip",
            "sourceType": "individual",
            # "startOffset": 0,
            # "endOffset": 50, #max result of ip-addresses / first request
            "filters": [],
            "sortColumn": "score",
            "sortDirection": "desc",
            "vulnTool": "sumip",
            "scanID": tenable_last_active_scan_id,
            "view": "all",
        },
        "sourceType": "individual",
        "scanID": tenable_last_active_scan_id,
        "sortField": "score",
        "sortDir": "desc",
        "type": "vuln",
    }

    # fire post-request to retrieve vulnerable IPs
    tenable_resp_analysis_ip = requests.post(
        tenable_uri, headers=tenable_header_val, json=tenable_ip_val, verify=False
    )

    # convert to json
    tenable_ip_data = tenable_resp_analysis_ip.json()

    # request max amount of records
    tenable_resp_total_ips = tenable_ip_data["response"]["totalRecords"]

    print("Tenable total IPs: " + tenable_resp_total_ips)
    print(
        "Tenable returned "
        + str(tenable_ip_data["response"]["returnedRecords"])
        + " records"
    )

    # in case there're more records available than returned based on "returnedRecords"-value
    # modify the endOffset
    if int(tenable_resp_total_ips) > tenable_ip_data["response"]["returnedRecords"]:
        tenable_ip_val["query"]["endOffset"] = tenable_resp_total_ips
        tenable_resp_analysis_ip = requests.post(
            tenable_uri, headers=tenable_header_val, json=tenable_ip_val, verify=False
        )

        # convert to json
        tenable_ip_data = tenable_resp_analysis_ip.json()

        # request max amount of records
        tenable_resp_total_ips = tenable_ip_data["response"]["totalRecords"]

    return tenable_ip_data


def get_tenable_cves(cfg, va_ip_address, tenable_last_active_scan_id):
    """
    Retrieve CVEs discovered by Tenable for IP address
    """

    # assemble the url
    tenable_uri = "https://" + cfg["tenable"]["server"] + "/rest/analysis"

    tenable_header_val = {
        "x-apikey": "accesskey="
        + cfg["tenable"]["api_accesskey"]
        + ";secretkey="
        + cfg["tenable"]["api_secretkey"]
        + ";",
        "User-Agent": "Tenable-TippingPoint-converter",
    }

    tenable_cve_val = {
        "query": {
            "status": -1,
            "createdTime": 0,
            "modifiedTime": 0,
            "type": "vuln",
            "tool": "vulndetails",
            # "tool": "sumcve",
            "sourceType": "individual",
            "startOffset": 0,
            "endOffset": 1000,  # retrieve 1K CVE-entries
            "filters": [
                {
                    "id": "ip",
                    "filterName": "ip",
                    "operator": "=",
                    "type": "vuln",
                    "isPredefined": "true",
                    "value": va_ip_address,
                }
            ],
            "vulnTool": "sumcve",
            "scanID": va_ip_address,
            "view": "all",
        },
        "sourceType": "individual",
        "scanID": tenable_last_active_scan_id,
        "type": "vuln",
    }

    tenable_resp_analysis_cve = requests.post(
        tenable_uri, headers=tenable_header_val, json=tenable_cve_val, verify=False
    )
    tenable_cve_data = tenable_resp_analysis_cve.json()

    # create list for cve:pluginID
    cves = {}
    for cve_vuln in tenable_cve_data["response"]["results"]:
        if cve_vuln["cve"] != "":
            cve_list = cve_vuln["cve"].split(",")
            for cve in cve_list:
                cve_details = {"pluginID": cve_vuln["pluginID"]}
                cves[cve] = cve_details

    return cves


def recast_vulnerability(cfg, va_ip_address, va_plugin_id):
    """
    Recast Vulnerability for IP address and given plugin id
    """

    # assemble the url
    tenable_uri = (
        "https://" + cfg["tenable"]["server"] + "/rest/deviceInfo?ip=" + va_ip_address
    )

    tenable_header_val = {
        "x-apikey": "accesskey="
        + cfg["tenable"]["api_accesskey"]
        + ";secretkey="
        + cfg["tenable"]["api_secretkey"]
        + ";",
        "User-Agent": "Tenable-TippingPoint-converter",
    }

    tenable_deviceInfo_response = requests.get(
        tenable_uri, headers=tenable_header_val, verify=False
    )
    tenable_deviceInfo_data = tenable_deviceInfo_response.json()

    # assemble the url
    tenable_uri = "https://" + cfg["tenable"]["server"] + "/rest/recastRiskRule"

    tenable_header_val = {
        "x-apikey": "accesskey="
        + cfg["tenable"]["api_accesskey"]
        + ";secretkey="
        + cfg["tenable"]["api_secretkey"]
        + ";",
        "User-Agent": "Tenable-TippingPoint-converter",
    }

    tenable_recast_val = {
        "repositories": [
            {"id": tenable_deviceInfo_data["response"]["repository"]["id"]}
        ],
        "plugin": {"id": va_plugin_id},
        "newSeverity": {"id": cfg["tenable"]["recast_severity"]},
        "hostType": "ip",
        "hostValue": va_ip_address,
        "comments": cfg["tenable"]["recast_comment"],
    }

    tenable_recast_response = requests.post(
        tenable_uri, headers=tenable_header_val, json=tenable_recast_val, verify=False
    )
    tenable_recast_data = tenable_recast_response.json()

    return tenable_recast_data


def build_rules_cves_map(ws_url, api_key):
    """
    Build dictionary of intrusion prevention rules with the ability to cover CVEs
    """

    # Constants
    RESULT_SET_SIZE = 5000

    # Return dictionary
    rules_cves = {}

    dict_len = 0
    offset = 0
    while True:

        url = ws_url + "/api/intrusionpreventionrules/search"
        data = {
            "maxItems": RESULT_SET_SIZE,
            "searchCriteria": [
                {"fieldName": "CVE", "stringTest": "not-equal", "stringValue": ""},
                {
                    "fieldName": "ID",
                    "idTest": "greater-than-or-equal",
                    "idValue": offset,
                },
                {
                    "fieldName": "ID",
                    "idTest": "less-than",
                    "idValue": offset + RESULT_SET_SIZE,
                },
            ],
        }
        post_header = {
            "Content-type": "application/json",
            "Authorization": f"ApiKey {api_key}",
            "api-version": "v1",
        }
        response = requests.post(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Error handling
        if "message" in response:
            if response["message"] == "Invalid API Key":
                raise ValueError("Invalid API Key")
        if "intrusionPreventionRules" not in response:
            if "message" in response:
                raise KeyError(response["message"])
            else:
                raise KeyError(response)

        rules = response["intrusionPreventionRules"]

        # Build dictionary ID: CVEs
        for rule in rules:
            cves = set()

            if "CVE" in rule:
                for cve in rule["CVE"]:
                    cves.add(str(cve.strip()))

            cves = sorted(cves)
            rules_cves[str(rule["ID"]).strip()] = cves

        if len(rules_cves) != 0 and len(rules_cves) == dict_len:
            dict_len = len(rules_cves)
            print("Number of rules in dictionary: {}".format(dict_len))
            break
        if len(rules_cves) != 0 and len(rules_cves) != dict_len:
            dict_len = len(rules_cves)

        offset += RESULT_SET_SIZE

    return rules_cves


def search_computer(hostname, ws_url, api_key):
    """
    Searches for computer and returns ID if present.
    Returns -1 is absent
    """

    url = ws_url + "/api/computers/search"
    data = {
        "maxItems": 1,
        "searchCriteria": [
            {"fieldName": "hostName", "stringTest": "equal", "stringValue": hostname}
        ],
    }
    post_header = {
        "Content-type": "application/json",
        "Authorization": f"ApiKey {api_key}",
        "api-version": "v1",
    }
    response = requests.post(
        url, data=json.dumps(data), headers=post_header, verify=True
    ).json()

    # Error handling
    if "message" in response:
        if response["message"] == "Invalid API Key":
            raise ValueError("Invalid API Key")

    computer_id = -1
    computer_ruleIDs = {}

    if len(response["computers"]) > 0:
        if "ID" in response["computers"][0]:
            computer_id = response["computers"][0]["ID"]

    if computer_id >= 0:
        if "ruleIDs" in response["computers"][0]["intrusionPrevention"]:
            computer_ruleIDs = response["computers"][0]["intrusionPrevention"][
                "ruleIDs"
            ]

    return {"ID": computer_id, "ruleIDs": computer_ruleIDs}


def search_ipsrule(identifier, ws_url, api_key):
    """
    Searches for IPS rule and returns ID if present.
    Returns -1 is absent
    """
    url = ws_url + "/api/intrusionpreventionrules/search"
    data = {
        "maxItems": 1,
        "searchCriteria": [
            {
                "fieldName": "identifier",
                "stringTest": "equal",
                "stringValue": identifier,
            }
        ],
    }
    post_header = {
        "Content-type": "application/json",
        "Authorization": f"ApiKey {api_key}",
        "api-version": "v1",
    }
    response = requests.post(
        url, data=json.dumps(data), headers=post_header, verify=True
    ).json()

    # Error handling
    if "intrusionPreventionRules" not in response:
        if "message" in response:
            raise KeyError(response["message"])
        else:
            raise KeyError(response)

    rule_id = -1
    if len(response["intrusionPreventionRules"]) > 0:
        if "ID" in response["intrusionPreventionRules"][0]:
            rule_id = response["intrusionPreventionRules"][0]["ID"]

    return {"ID": rule_id}


def rule_present(computer, rule, ws_url, api_key):
    """
    Ensure rule is present
    """

    if rule["ID"] not in computer["ruleIDs"]:
        url = (
            ws_url
            + "/api/computers/"
            + str(computer["ID"])
            + "/intrusionprevention/assignments"
        )
        data = {"ruleIDs": str(rule["ID"])}
        post_header = {
            "Content-type": "application/json",
            "Authorization": f"ApiKey {api_key}",
            "api-version": "v1",
        }
        computer_response = requests.post(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Rule added
        return 201

    # Rule already present
    return 200


def rule_absent(computer, rule, ws_url, api_key):
    """
    Ensure rule is absent
    """

    if rule["ID"] in computer["ruleIDs"]:
        url = (
            ws_url
            + "/api/computers/"
            + str(computer["ID"])
            + "/intrusionprevention/assignments/"
            + str(rule["ID"])
        )
        data = {}
        post_header = {
            "Content-type": "application/json",
            "Authorization": f"ApiKey {api_key}",
            "api-version": "v1",
        }
        computer_response = requests.delete(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Rule deleted
        return 201

    # Rule already absent
    return 200


def update_policy(ws_url, api_key, rules_cves, cves_list, hostname, ip, query):
    """
    Returns a result object
    """

    # Result dictionary
    result = dict(changed=False, message="")

    #
    # Module logic
    #
    # Retrieves intrusion prevention rules based on a list of given CVEs
    rules = set()
    rules_mapping = set()
    matched_list = set()
    unmatched_list = set()
    match_counter = 0
    unmatch_counter = len(query)

    for cve in query:
        matched = False
        attack_vector = ""
        criticality = ""
        if str(cve) in cves_list:
            attack_vector = " N"
            criticality = str(cves_list[str(cve)])
        else:
            attack_vector = ""
        for rule in rules_cves:
            if str(cve) in rules_cves[str(rule)]:
                # Query rule identifier
                url = ws_url + "/api/intrusionpreventionrules/search"
                data = {
                    "maxItems": 1,
                    "searchCriteria": [
                        {"fieldName": "ID", "idTest": "equal", "idValue": str(rule)}
                    ],
                }
                post_header = {
                    "Content-type": "application/json",
                    "Authorization": f"ApiKey {api_key}",
                    "api-version": "v1",
                }
                response = requests.post(
                    url, data=json.dumps(data), headers=post_header, verify=True
                ).json()
                rules.add(response["intrusionPreventionRules"][0]["identifier"])
                rules_mapping.add(
                    response["intrusionPreventionRules"][0]["identifier"]
                    + " ("
                    + str(cve)
                    + ")"
                    + attack_vector
                    + criticality
                )
                matched_list.add(str(cve))
                if matched == False:
                    match_counter += 1
                    unmatch_counter -= 1
                    matched = True
        if matched == False:
            unmatched_list.add(str(cve))

    # Populate result set
    result["json"] = {
        "rules_covering": rules,
        "rules_mapping": rules_mapping,
        "cves_matched": matched_list,
        "cves_unmatched": unmatched_list,
        "cves_matched_count": match_counter,
        "cves_unmatched_count": unmatch_counter,
        "updated": False,
    }

    # Search for the computer object to modify it's policy
    # First by hostname, second by IP.
    print("Searching computer {}.".format(hostname))
    computer = search_computer(hostname, ws_url, api_key)
    if computer["ID"] == -1:
        print("Searching computer {}.".format(ip))
        computer = search_computer(ip, ws_url, api_key)

    if computer["ID"] == -1:
        # TODO: DON'T DO RECAST IF COMPUTER IS NOT FOUND
        print("!!! Computer not found !!!")
        return result
    else:
        print("Updating computer {}".format(str(computer["ID"])))

    # Ensure, that matching ips rules are present within the computers policy
    print("Ensuring that the covering rules are set.")
    for identifier in result["json"]["rules_covering"]:
        rule_present(
            computer, search_ipsrule(identifier, ws_url, api_key), ws_url, api_key
        )

    print("Policy updated.")
    result["json"] = {
        "rules_covering": rules,
        "rules_mapping": rules_mapping,
        "cves_matched": matched_list,
        "cves_unmatched": unmatched_list,
        "cves_matched_count": match_counter,
        "cves_unmatched_count": unmatch_counter,
        "updated": True,
    }

    return result


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument("--query", nargs="*", type=str, help="cves to handle")
    args = parser.parse_args()

    with open("config.yml", "r") as ymlfile:
        cfg = yaml.load(ymlfile, Loader=yaml.FullLoader)

    asset_id = 0
    asset_cves = set()
    asset_vuls_cves = {}
    print("\nRunning Cloud One Workload Security for Tenable vulnerabilities")

    print("Build IPS rules CVEs dictionary")
    rules_cves = {}
    rules_cves = build_rules_cves_map(
        cfg["deepsecurity"]["server"], cfg["deepsecurity"]["api_key"]
    )

    cves_list = {}
    # If a cves_network.cache file generated by nvd_extract_av_network is found,
    # we load the hash map to easily lookup the attack vector and the
    # riticality. Only network exploitable vulnerabilities currently
    # exist in the cache file
    if os.path.isfile("../cves_network.cache"):
        with open("../cves_network.cache", "rb") as fp:
            cves_list = pickle.load(fp)
            print("CVEs cache with attack vector network loaded.")

    if args.query == None:
        print("Requesting vulnerability scan reports from Tenable")

        # query last active scan id from tennable
        tenable_last_active_scan_id = get_tenable_last_active_scan_id(cfg)

        # query tenable ip data
        tenable_ip_data = get_tenable_ip_data(cfg, tenable_last_active_scan_id)

        # request analysed ips count
        tenable_resp_total_ips = tenable_ip_data["response"]["totalRecords"]

        # in case there're more records available than returned based on "returnedRecords"-value
        # modify the endOffset
        if int(tenable_resp_total_ips) > tenable_ip_data["response"]["returnedRecords"]:
            tenable_ip_val["query"]["endOffset"] = tenable_resp_total_ips
            tenable_resp_analysis_ip = requests.post(
                tenable_uri,
                headers=tenable_header_val,
                json=tenable_ip_val,
                verify=False,
            )

            # convert to json
            tenable_ip_data = tenable_resp_analysis_ip.json()

            # request max amount of records
            tenable_resp_total_ips = tenable_ip_data["response"]["totalRecords"]

        print()

        # update workload security policy for computer
        for ip in tenable_ip_data["response"]["results"]:
            va_ip_address = ip["ip"]
            va_host_name = ip["dnsName"]

            asset_cves = get_tenable_cves(
                cfg, va_ip_address, tenable_last_active_scan_id
            )

            print("Updating policy for {}".format(va_ip_address))
            result = update_policy(
                cfg["deepsecurity"]["server"],
                cfg["deepsecurity"]["api_key"],
                rules_cves,
                cves_list,
                va_host_name,
                va_ip_address,
                asset_cves,
            )

            # Return key/value results
            # print("Rules covering CVEs:  {}".format(result['json']['rules_covering']))
            print("Rules mapping:        {}".format(result["json"]["rules_mapping"]))
            print("CVEs matched:         {}".format(result["json"]["cves_matched"]))
            print(
                "CVEs matched count:   {}".format(result["json"]["cves_matched_count"])
            )
            print("CVEs unmatched:       {}".format(result["json"]["cves_unmatched"]))
            print(
                "CVEs unmatched count: {}".format(
                    result["json"]["cves_unmatched_count"]
                )
            )
            print("Policy updated:       {}\n".format(result["json"]["updated"]))

            if result["json"]["updated"]:
                for cve in result["json"]["cves_matched"]:
                    print("Creating exception for {}".format(cve))
                    recast_vulnerability(
                        cfg, va_ip_address, asset_cves[str(cve)]["pluginID"]
                    )

            print()

    else:
        asset_cves = args.query

    print("Done.")


if __name__ == "__main__":
    main()
