#!/usr/bin/env python3

DOCUMENTATION = """
---
module: policy_on_query.py

short_description: Assigns IPS rules to instances managed by
                   Cloud One Workload Security based on a list of CVEs.

description:
    - "TODO"

options:
    --query       cves to handle

author:
    - Markus Winkler (markus_winkler@trendmicro.com)
"""

EXAMPLES = """
./policy_on_query.py --query 'CVE-2002-1700'

./policy_on_query.py --query $(./parse.sh vm_report.csv)
"""

RETURN = """
TODO
"""

import ssl

ssl._create_default_https_context = ssl._create_unverified_context
import urllib3

urllib3.disable_warnings()
import argparse
import json
import os
import os.path
import pickle
import sys
import logging
import requests
import yaml

_LOGGER = logging.getLogger(__name__)
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s (%(threadName)s) [%(funcName)s] %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S')
logging.getLogger("requests").setLevel(logging.WARNING)
logging.getLogger("urllib3").setLevel(logging.WARNING)

def build_rules_cves_map(ws_url, api_key):
    """
    Build dictionary of intrusion prevention rules with the ability to cover CVEs
    'ID': (CVEs)
    """

    # Constants
    RESULT_SET_SIZE = 5000

    # Return dictionary
    rules_cves = {}

    dict_len = 0
    offset = 0
    while True:
        url = "https://" + ws_url + "/api/intrusionpreventionrules/search"
        data = {
            "maxItems": RESULT_SET_SIZE,
            "searchCriteria": [
                {"fieldName": "CVE", "stringTest": "not-equal", "stringValue": ""},
                {
                    "fieldName": "ID",
                    "idTest": "greater-than-or-equal",
                    "idValue": offset,
                },
                {
                    "fieldName": "ID",
                    "idTest": "less-than",
                    "idValue": offset + RESULT_SET_SIZE,
                },
            ],
        }
        post_header = {
            "Content-type": "application/json",
            "api-secret-key": api_key,
            "api-version": "v1",
        }
        response = requests.post(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Error handling
        if "message" in response:
            if response["message"] == "Invalid API Key":
                raise ValueError("Invalid API Key")
        if "intrusionPreventionRules" not in response:
            if "message" in response:
                raise KeyError(response["message"])
            else:
                raise KeyError(response)

        rules = response["intrusionPreventionRules"]

        # Build dictionary ID: CVEs
        for rule in rules:
            cves = set()

            if "CVE" in rule:
                for cve in rule["CVE"]:
                    cves.add(str(cve.strip()))

            cves = sorted(cves)
            rules_cves[str(rule["ID"]).strip()] = cves

        if len(rules_cves) != 0 and len(rules_cves) == dict_len:
            dict_len = len(rules_cves)
            _LOGGER.info("Number of rules in dictionary: {}".format(dict_len))
            break
        if len(rules_cves) != 0 and len(rules_cves) != dict_len:
            dict_len = len(rules_cves)

        offset += RESULT_SET_SIZE

    return rules_cves


def search_computer(hostname, ws_url, api_key):
    """
    Searches for computer and returns ID if present.
    Returns -1 is absent
    {"ID": computer_id, "ruleIDs": computer_ruleIDs}
    """

    url = "https://" + ws_url + "/api/computers/search"
    data = {
        "maxItems": 1,
        "searchCriteria": [
            {"fieldName": "hostName", "stringTest": "equal", "stringValue": hostname}
        ],
    }
    post_header = {
        "Content-type": "application/json",
        "api-secret-key": api_key,
        "api-version": "v1",
    }
    response = requests.post(
        url, data=json.dumps(data), headers=post_header, verify=True
    ).json()

    # Error handling
    if "message" in response:
        if response["message"] == "Invalid API Key":
            raise ValueError("Invalid API Key")

    computer_id = -1
    computer_ruleIDs = {}

    if len(response["computers"]) > 0:
        if "ID" in response["computers"][0]:
            computer_id = response["computers"][0]["ID"]

    if computer_id >= 0:
        if "ruleIDs" in response["computers"][0]["intrusionPrevention"]:
            computer_ruleIDs = response["computers"][0]["intrusionPrevention"][
                "ruleIDs"
            ]

    return {"ID": computer_id, "ruleIDs": computer_ruleIDs}


def search_ipsrule(identifier, ws_url, api_key):
    """
    Searches for IPS rule and returns ID if present.
    Returns -1 is absent
    {"ID": rule_id}
    """

    url = "https://" + ws_url + "/api/intrusionpreventionrules/search"
    data = {
        "maxItems": 1,
        "searchCriteria": [
            {
                "fieldName": "identifier",
                "stringTest": "equal",
                "stringValue": identifier,
            }
        ],
    }
    post_header = {
        "Content-type": "application/json",
        "api-secret-key": api_key,
        "api-version": "v1",
    }
    response = requests.post(
        url, data=json.dumps(data), headers=post_header, verify=True
    ).json()

    # Error handling
    if "intrusionPreventionRules" not in response:
        if "message" in response:
            raise KeyError(response["message"])
        else:
            raise KeyError(response)

    rule_id = -1
    if len(response["intrusionPreventionRules"]) > 0:
        if "ID" in response["intrusionPreventionRules"][0]:
            rule_id = response["intrusionPreventionRules"][0]["ID"]

    return {"ID": rule_id}


def rule_present(computer, rule, ws_url, api_key):
    """
    Ensure rule is present
    """

    if rule["ID"] not in computer["ruleIDs"]:
        url = (
            "https://"
            + ws_url
            + "/api/computers/"
            + str(computer["ID"])
            + "/intrusionprevention/assignments"
        )
        data = {"ruleIDs": str(rule["ID"])}
        post_header = {
            "Content-type": "application/json",
            "api-secret-key": api_key,
            "api-version": "v1",
        }
        computer_response = requests.post(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Rule added
        return 201

    # Rule already present
    return 200


def rule_absent(computer, rule, ws_url, api_key):
    """
    Ensure rule is absent
    """

    if rule["ID"] in computer["ruleIDs"]:
        url = (
            "https://"
            + ws_url
            + "/api/computers/"
            + str(computer["ID"])
            + "/intrusionprevention/assignments/"
            + str(rule["ID"])
        )
        data = {}
        post_header = {
            "Content-type": "application/json",
            "api-secret-key": api_key,
            "api-version": "v1",
        }
        computer_response = requests.delete(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Rule deleted
        return 201

    # Rule already absent
    return 200


def run_module(ws_url, api_key, rules_cves, hostname, query):

    # Result dictionary
    result = dict(changed=False, message="")

    #
    # Module logic
    #
    # Retrieves intrusion prevention rules based on a list of given CVEs
    rules = set()
    rules_mapping = set()
    matched_list = set()
    unmatched_list = set()
    match_counter = 0
    unmatch_counter = len(query)

    for cve in query:
        matched = False
        for rule in rules_cves:
            if str(cve) in rules_cves[str(rule)]:
                # Query rule identifier
                url = "https://" + ws_url + "/api/intrusionpreventionrules/search"
                data = {
                    "maxItems": 1,
                    "searchCriteria": [
                        {"fieldName": "ID", "idTest": "equal", "idValue": str(rule)}
                    ],
                }
                post_header = {
                    "Content-type": "application/json",
                    "api-secret-key": api_key,
                    "api-version": "v1",
                }
                response = requests.post(
                    url, data=json.dumps(data), headers=post_header, verify=True
                ).json()
                rules.add(response["intrusionPreventionRules"][0]["identifier"])
                rules_mapping.add(
                    response["intrusionPreventionRules"][0]["identifier"]
                    + " ("
                    + str(cve)
                    + ")"
                )
                matched_list.add(str(cve))
                if matched == False:
                    match_counter += 1
                    unmatch_counter -= 1
                    matched = True
        if matched == False:
            unmatched_list.add(str(cve))

    # Populate result set
    result["json"] = {
        "rules_covering": rules,
        "rules_mapping": rules_mapping,
        "cves_matched": matched_list,
        "cves_unmatched": unmatched_list,
        "cves_matched_count": match_counter,
        "cves_unmatched_count": unmatch_counter,
    }

    # Return key/value results
    _LOGGER.info("Rules covering CVEs:  {}".format(result["json"]["rules_covering"]))
    _LOGGER.info("Rules mapping:        {}".format(result["json"]["rules_mapping"]))
    _LOGGER.info("CVEs matched:         {}".format(result["json"]["cves_matched"]))
    _LOGGER.info("CVEs matched count:   {}".format(result["json"]["cves_matched_count"]))
    _LOGGER.info("CVEs unmatched:       {}".format(result["json"]["cves_unmatched"]))
    _LOGGER.info("CVEs unmatched count: {}".format(result["json"]["cves_unmatched_count"]))

    _LOGGER.debug("Accessing computer object for {}".format(hostname))
    computer = search_computer(hostname, ws_url, api_key)

    _LOGGER.info("Ensuring that the rules are set")
    for identifier in result["json"]["rules_covering"]:
        rule_present(
            computer, search_ipsrule(identifier, ws_url, api_key), ws_url, api_key
        )

    _LOGGER.debug("All set.")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--query", nargs="*", type=str, help="cves to handle")
    args = parser.parse_args()

    with open("config.yml", "r") as ymlfile:
        cfg = yaml.load(ymlfile, Loader=yaml.FullLoader)

    _LOGGER.info("Running Cloud One Workload Security for vulnerabilities by CVE query")

    _LOGGER.info("Build IPS rules CVEs dictionary")
    rules_cves = {}
    rules_cves = build_rules_cves_map(
        cfg["deepsecurity"]["server"], cfg["deepsecurity"]["api_key"]
    )

    for computer in cfg["computers"]:
        run_module(
            cfg["deepsecurity"]["server"],
            cfg["deepsecurity"]["api_key"],
            rules_cves,
            computer,
            args.query,
        )


if __name__ == "__main__":
    main()
