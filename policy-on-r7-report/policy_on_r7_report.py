#!/usr/bin/env python3

DOCUMENTATION = """
---
module: policy_on_r7_report.py

short_description: Retrieves CVEs discovered by Rapid7 Vulnerability
                   Management and assigns IPS rules to instances managed by
                   Cloud One Workload Security.

description:
    - "TODO"

options:
    none

author:
    - Markus Winkler (markus_winkler@trendmicro.com)
"""

EXAMPLES = """
./policy_on_r7_report.py
"""

RETURN = """
TODO
"""

import ssl

ssl._create_default_https_context = ssl._create_unverified_context
import urllib3

urllib3.disable_warnings()
import json
import logging
import requests
import yaml
import sys
from requests.auth import HTTPBasicAuth

_LOGGER = logging.getLogger(__name__)
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s (%(threadName)s) [%(funcName)s] %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S')
logging.getLogger("requests").setLevel(logging.WARNING)
logging.getLogger("urllib3").setLevel(logging.WARNING)

def r7_asset_search(r7_url, r7_username, r7_password, r7_asset):
    """
    Search for an asset within Rapid7.
    Returns R7 asset id
    """
    url = "https://" + r7_url + "/api/3/assets/search"
    data = {
        "match": "all",
        "filters": [{"field": "host-name", "operator": "is", "value": r7_asset}],
    }
    post_header = {
        "Accept": "application/json;charset=UTF-8",
        "Content-type": "application/json",
    }
    response = requests.post(
        url,
        data=json.dumps(data),
        headers=post_header,
        verify=False,
        auth=HTTPBasicAuth(r7_username, r7_password),
    ).json()

    if "status" in response:
        if response["status"] >= 400:
            if "arguments supplied" in response["message"]:
                _LOGGER.error("Asset not found. %s", response["message"])
                return -1
            else:
                raise Exception(
                    "Authentication to Rapid7 not successful"
                    + " or service unavailable. "
                    + response["message"]
                )
    resources = response.get("resources")
    if not resources:
        _LOGGER.warning("no scan")
        return -1
    id = resources[0].get("id")
    _LOGGER.debug("R7 asset ID %d", id)
    return id


def r7_asset_vulnerabilities(r7_url, r7_username, r7_password, asset_id):
    """
    Retrieve vulnerabilities of asset
    Returns a dictionary of vulnerailities (key) and cves (value set))
    for the given asset
    """
    # Return dictionary
    asset_vuls_cves = {}

    url = "https://" + r7_url + "/api/3/assets/" + str(asset_id) + "/vulnerabilities?size=10000"

    response = requests.get(
        url, verify=False, auth=HTTPBasicAuth(r7_username, r7_password)
    ).json()

    if "status" in response:
        if response["status"] >= 400:
            raise Exception(
                "Authentication to Rapid7 not successful"
                + " or service unavailable.\n"
                + response["message"]
            )

    asset_cves = set()

    for vul in response["resources"]:
        asset_cves = r7_vulnerability_cves(r7_url, r7_username, r7_password, vul["id"])
        cves = set()

        if asset_cves != "":
            for cve in asset_cves:
                cves.add(cve)
        asset_vuls_cves[str(vul["id"]).strip()] = cves

    return asset_vuls_cves


def r7_vulnerability_cves(r7_url, r7_username, r7_password, vul_id):
    """
    Retrieve cves of vulnerability
    Returns a set of cves if present in the vulnerability
    """
    url = "https://" + r7_url + "/api/3/vulnerabilities/" + str(vul_id)

    response = requests.get(
        url, verify=False, auth=HTTPBasicAuth(r7_username, r7_password)
    ).json()

    if "status" in response:
        if response["status"] >= 400:
            raise Exception(
                "Authentication to Rapid7 not successful"
                + " or service unavailable.\n"
                + response["message"]
            )

    if "cves" in response:
        return response["cves"]
    else:
        return ""


def r7_create_exception_for_instance(
    r7_url, r7_username, r7_password, asset_id, vul_id
):
    """
    Create an exception for a given vulnerability and instance
    """
    submitter_name = "nxadmin"  #
    submitter_user = 1

    url = "https://" + r7_url + "/api/3/vulnerability_exceptions"
    data = {
        "review": {"comment": "Auto approved by submitter."},
        "scope": {"id": asset_id, "type": "instance", "vulnerability": vul_id},
        "state": "approved",
        "submit": {
            "comment": "Deep Security IPS rules active",
            "name": submitter_name,
            "reason": "Compensating Control",
            "user": submitter_user,
        },
    }
    post_header = {
        "Accept": "application/json;charset=UTF-8",
        "Content-type": "application/json",
    }
    response = requests.post(
        url,
        data=json.dumps(data),
        headers=post_header,
        verify=False,
        auth=HTTPBasicAuth(r7_username, r7_password),
    ).json()

    if "status" in response:
        if response["status"] == 200:
            _LOGGER.info("Exception for %s created. %s", vul_id, response["message"])
            return 0
        if response["status"] >= 400:
            if "already exists" in response["message"]:
                _LOGGER.warning("Exception for %s already exists.", vul_id)
            else:
                raise Exception(
                    "Authentication to Rapid7 not successful"
                    + " or service unavailable. "
                    + response["message"]
                )


def build_rules_cves_map(ws_url, api_key, skip=True):
    """
    Build dictionary of intrusion prevention rules with the ability to cover CVEs
    """
    # Constants
    RESULT_SET_SIZE = 5000

    # Return dictionary
    rules_cves = {}

    dict_len = 0
    offset = 0
    skipped = 0
    while True:

        url = "https://" + ws_url + "/api/intrusionpreventionrules/search"
        data = {
            "maxItems": RESULT_SET_SIZE,
            "searchCriteria": [
                {"fieldName": "CVE", "stringTest": "not-equal", "stringValue": ""},
                {
                    "fieldName": "ID",
                    "idTest": "greater-than-or-equal",
                    "idValue": offset,
                },
                {
                    "fieldName": "ID",
                    "idTest": "less-than",
                    "idValue": offset + RESULT_SET_SIZE,
                },
            ],
        }
        post_header = {
            "Content-type": "application/json",
            "Authorization": f"ApiKey {api_key}",
            "api-version": "v1",
        }
        response = requests.post(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Error handling
        if "message" in response:
            if response["message"] == "Invalid API Key":
                raise ValueError("Invalid API Key")
        if "intrusionPreventionRules" not in response:
            if "message" in response:
                raise KeyError(response["message"])
            else:
                raise KeyError(response)

        rules = response["intrusionPreventionRules"]

        # Build dictionary ID: CVEs
        for rule in rules:
            cves = set()

            if rule.get("recommendationsMode", None) != "enabled" and skip:
                skipped += 1
                continue
            
            if "CVE" in rule:
                for cve in rule["CVE"]:
                    cves.add(str(cve.strip()))

            cves = sorted(cves)
            rules_cves[str(rule["ID"]).strip()] = cves

        if len(rules_cves) != 0 and len(rules_cves) == dict_len:
            dict_len = len(rules_cves)
            _LOGGER.info("Number of rules in dictionary: %d", dict_len)
            _LOGGER.info("Number of skipped rules: %d", skipped)
            break
        if len(rules_cves) != 0 and len(rules_cves) != dict_len:
            dict_len = len(rules_cves)

        offset += RESULT_SET_SIZE

    return rules_cves


def list_computers(ws_url, api_key, filter=""):
    """
    Build dictionary of computers
    """
    # Constants
    RESULT_SET_SIZE = 5000

    # Return dictionary
    computers = {}

    dict_len = 0
    offset = 0
    while True:

        url = "https://" + ws_url + "/api/computers/search"
        data = {
            "maxItems": RESULT_SET_SIZE,
            "searchCriteria": [
                {"fieldName": "hostName", "stringTest": "equal", "stringValue": "%" + filter + "%"},
                {
                    "fieldName": "ID",
                    "idTest": "greater-than-or-equal",
                    "idValue": offset,
                },
                {
                    "fieldName": "ID",
                    "idTest": "less-than",
                    "idValue": offset + RESULT_SET_SIZE,
                },
            ],
        }
        post_header = {
            "Content-type": "application/json",
            "Authorization": f"ApiKey {api_key}",
            "api-version": "v1",
        }
        response = requests.post(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Error handling
        if "message" in response:
            if response["message"] == "Invalid API Key":
                raise ValueError("Invalid API Key")

        # Build dictionary hostName: ID, displayName
        for computer in response["computers"]:
            computers[str(computer["hostName"]).strip()] = { computer.get("ID", 0), computer.get("displayName", "") }

        if len(computers) != 0 and len(computers) == dict_len:
            dict_len = len(computers)
            _LOGGER.info("Number of computers in dictionary: %d", dict_len)
            break
        if len(computers) != 0 and len(computers) != dict_len:
            dict_len = len(computers)

        offset += RESULT_SET_SIZE

    return computers


def search_computer(hostname, ws_url, api_key):
    """
    Searches for computer and returns ID if present.
    Returns -1 is absent
    """

    url = "https://" + ws_url + "/api/computers/search"
    data = {
        "maxItems": 1,
        "searchCriteria": [
            {"fieldName": "hostName", "stringTest": "equal", "stringValue": hostname}
        ],
    }
    post_header = {
        "Content-type": "application/json",
        "Authorization": f"ApiKey {api_key}",
        "api-version": "v1",
    }
    response = requests.post(
        url, data=json.dumps(data), headers=post_header, verify=True
    ).json()

    # Error handling
    if "message" in response:
        if response["message"] == "Invalid API Key":
            raise ValueError("Invalid API Key")

    computer_id = -1
    computer_ruleIDs = {}

    if len(response["computers"]) > 0:
        if "ID" in response["computers"][0]:
            computer_id = response["computers"][0]["ID"]

    if computer_id > -1:
        if "ruleIDs" in response["computers"][0]["intrusionPrevention"]:
            computer_ruleIDs = response["computers"][0]["intrusionPrevention"][
                "ruleIDs"
            ]

    return {"ID": computer_id, "ruleIDs": computer_ruleIDs}


def search_ipsrule(identifier, ws_url, api_key):
    """
    Searches for IPS rule and returns ID if present.
    Returns -1 is absent
    """
    url = "https://" + ws_url + "/api/intrusionpreventionrules/search"
    data = {
        "maxItems": 1,
        "searchCriteria": [
            {
                "fieldName": "identifier",
                "stringTest": "equal",
                "stringValue": identifier,
            }
        ],
    }
    post_header = {
        "Content-type": "application/json",
        "Authorization": f"ApiKey {api_key}",
        "api-version": "v1",
    }
    response = requests.post(
        url, data=json.dumps(data), headers=post_header, verify=True
    ).json()

    # Error handling
    if "intrusionPreventionRules" not in response:
        if "message" in response:
            raise KeyError(response["message"])
        else:
            raise KeyError(response)

    rule_id = -1
    if len(response["intrusionPreventionRules"]) > 0:
        if "ID" in response["intrusionPreventionRules"][0]:
            rule_id = response["intrusionPreventionRules"][0]["ID"]

    return {"ID": rule_id}


def rule_present(computer, rule, ws_url, api_key):
    """
    Ensure rule is present
    """

    if rule["ID"] not in computer["ruleIDs"]:

        _LOGGER.info("Assigning rule %s", str(rule["ID"]))

        url = (
            "https://" + ws_url
            + "/api/computers/"
            + str(computer["ID"])
            + "/intrusionprevention/assignments"
        )
        data = {"ruleIDs": str(rule["ID"])}
        post_header = {
            "Content-type": "application/json",
            "Authorization": f"ApiKey {api_key}",
            "api-version": "v1",
        }
        computer_response = requests.post(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Rule added
        return 201

    _LOGGER.info("Rule %s already assigned.", str(rule["ID"]))

    # Rule already present
    return 200


def rule_absent(computer, rule, ws_url, api_key):
    """
    Ensure rule is absent
    """

    if rule["ID"] in computer["ruleIDs"]:

        _LOGGER.info("Unassigning rule %s", str(rule["ID"]))

        url = (
            "https://" + ws_url
            + "/api/computers/"
            + str(computer["ID"])
            + "/intrusionprevention/assignments/"
            + str(rule["ID"])
        )
        data = {}
        post_header = {
            "Content-type": "application/json",
            "Authorization": f"ApiKey {api_key}",
            "api-version": "v1",
        }
        computer_response = requests.delete(
            url, data=json.dumps(data), headers=post_header, verify=True
        ).json()

        # Rule deleted
        return 201

    # Rule already absent
    return 200


def analyze_cves(ws_url, api_key, rules_cves, query):
    """
    Checks cves against Deep Security database
    """

    #
    # Module logic
    #
    # Retrieves intrusion prevention rules based on a list of given CVEs
    rules = set()
    rules_mapping = set()
    matched_list = set()
    unmatched_list = set()
    match_counter = 0
    unmatch_counter = len(query)

    for cve in query:
        matched = False
        for rule in rules_cves:
            if str(cve) in rules_cves[str(rule)]:
                # Query rule identifier
                url = "https://" + ws_url + "/api/intrusionpreventionrules/search"
                data = {
                    "maxItems": 1,
                    "searchCriteria": [
                        {"fieldName": "ID", "idTest": "equal", "idValue": str(rule)}
                    ],
                }
                post_header = {
                    "Content-type": "application/json",
                    "Authorization": f"ApiKey {api_key}",
                    "api-version": "v1",
                }
                response = requests.post(
                    url, data=json.dumps(data), headers=post_header, verify=True
                ).json()
                rules.add(response["intrusionPreventionRules"][0]["identifier"])
                rules_mapping.add(
                    response["intrusionPreventionRules"][0]["identifier"]
                    + " ("
                    + str(cve)
                    + ")"
                )
                matched_list.add(str(cve))
                if matched == False:
                    match_counter += 1
                    unmatch_counter -= 1
                    matched = True
        if matched == False:
            unmatched_list.add(str(cve))

    # Populate result set
    result = {
        "rules_covering": rules,
        "rules_mapping": rules_mapping,
        "cves_matched": matched_list,
        "cves_unmatched": unmatched_list,
        "cves_matched_count": match_counter,
        "cves_unmatched_count": unmatch_counter,
    }

    return result


def assign_rules(ws_url, api_key, resulting_cves, hostname):

    result = -1

    # Search for the computer object to modify it's policy
    _LOGGER.debug("Accessing computer object for %s", hostname)
    computer = search_computer(hostname, ws_url, api_key)

    if computer["ID"] == -1:
        _LOGGER.error("Computer %s not found.", hostname)
        return result

    # Ensure, that matching ips rules are present within the computers policy
    for identifier in resulting_cves["rules_covering"]:
        result = rule_present(
            computer, search_ipsrule(identifier, ws_url, api_key), ws_url, api_key
        )

    _LOGGER.info("Policy updated.")

    return result


def main():

    with open("config.yml", "r") as ymlfile:
        cfg = yaml.load(ymlfile, Loader=yaml.FullLoader)

    asset_id = 0
    asset_cves = set()
    asset_vuls_cves = {}

    _LOGGER.debug("Build IPS rules CVEs dictionary.")
    rules_cves = {}
    rules_cves = build_rules_cves_map(
        cfg["deepsecurity"]["server"], cfg["deepsecurity"]["api_key"], cfg["deepsecurity"]["skip"]
    )

    if cfg["computers"]["list"] == "all":
        cfg["computers"]["list"] = list_computers(cfg["deepsecurity"]["server"], cfg["deepsecurity"]["api_key"], cfg["computers"].get("filter", "%"))
    
    for computer in cfg["computers"]["list"]:

        _LOGGER.info("Requesting vulnerability scan report for %s", computer)
        asset_id = r7_asset_search(
            cfg["rapid7"]["server"],
            cfg["rapid7"]["username"],
            cfg["rapid7"]["password"],
            computer,
        )
        if asset_id == -1:
            continue

        asset_vuls_cves = r7_asset_vulnerabilities(
            cfg["rapid7"]["server"],
            cfg["rapid7"]["username"],
            cfg["rapid7"]["password"],
            asset_id,
        )

        for vul_id in asset_vuls_cves:
            for cve in asset_vuls_cves[vul_id]:
                asset_cves.add(str(cve))

        _LOGGER.info("CVEs to handle: %s", str(len(asset_cves)))
        _LOGGER.debug("CVEs to handle: %s", str(asset_cves))
        _LOGGER.debug("Check CVEs against Deep Security.")
        resulting_cves = analyze_cves(
            cfg["deepsecurity"]["server"],
            cfg["deepsecurity"]["api_key"],
            rules_cves,
            asset_cves,
        )

        if resulting_cves["cves_matched_count"]:
            _LOGGER.info("Updating Deep Security Policy for %s", computer)

            result = assign_rules(
                cfg["deepsecurity"]["server"],
                cfg["deepsecurity"]["api_key"],
                resulting_cves,
                computer,
            )

            if result == -1:
                _LOGGER.warning("Name mismatch on computer %s in between Rapid7 and Deep Security.", computer)

            # Return key/value results
            _LOGGER.info("Rules mapping: {}.".format(resulting_cves["rules_mapping"]))

            # create exceptions for vulnerabilities with the matched cves
            #
            # NOTE:
            # currently, an exception is created when at least one cve from
            # a vulnerability is covered by DS! Improvement needed
            for cve in resulting_cves["cves_matched"]:
                for vul_id in asset_vuls_cves:
                    if cve in asset_vuls_cves[vul_id]:

                        r7_create_exception_for_instance(
                            cfg["rapid7"]["server"],
                            cfg["rapid7"]["username"],
                            cfg["rapid7"]["password"],
                            asset_id,
                            vul_id,
                        )

        else:
            _LOGGER.warning("No matching IPS rules found.")
            result = -1


if __name__ == "__main__":
    main()
